"""
Sistema de IA Avan√ßado para ZapChicken
An√°lise profunda com machine learning e insights estrat√©gicos
"""

import pandas as pd
import numpy as np
from typing import List, Dict, Any, Optional, Tuple
from pathlib import Path
from datetime import datetime, timedelta
import re
from collections import Counter
# Machine Learning n√£o dispon√≠vel no Vercel - usando an√°lise estat√≠stica
ML_AVAILABLE = False
import warnings
warnings.filterwarnings('ignore')

from .zapchicken_processor import ZapChickenProcessor

class ZapChickenAI:
    """Sistema de IA com An√°lise Estat√≠stica para ZapChicken (Vercel Compatible)"""
    
    def __init__(self, processor: ZapChickenProcessor):
        self.processor = processor
        self.conversation_history = []
        self.insights_cache = {}
        
    def process_question(self, question: str) -> str:
        """Processa pergunta com an√°lise avan√ßada"""
        question_lower = question.lower()
        
        # An√°lise de vendas com machine learning
        if any(word in question_lower for word in ['comprou', 'vendeu', 'venda', 'pedido', 'data']):
            return self.analyze_sales_advanced(question)
        
        # An√°lise de clientes com segmenta√ß√£o
        elif any(word in question_lower for word in ['inativo', 'inatividade', 'reativar', 'cliente']):
            return self.analyze_customers_advanced(question)
        
        # An√°lise de ticket m√©dio com clustering
        elif any(word in question_lower for word in ['ticket', 'm√©dio', 'alto', 'premium', 'valor']):
            return self.analyze_ticket_advanced(question)
        
        # An√°lise geogr√°fica com heatmaps
        elif any(word in question_lower for word in ['bairro', 'cidade', 'local', 'geogr√°fico', 'regi√£o']):
            return self.analyze_geographic_advanced(question)
        
        # An√°lise de produtos com recomenda√ß√£o
        elif any(word in question_lower for word in ['produto', 'item', 'mais vendido', 'categoria']):
            return self.analyze_products_advanced(question)
        
        # Previs√µes e tend√™ncias
        elif any(word in question_lower for word in ['tend√™ncia', 'previs√£o', 'futuro', 'crescimento', 'predi√ß√£o']):
            return self.analyze_predictions_advanced(question)
        
        # An√°lise de sazonalidade
        elif any(word in question_lower for word in ['sazonal', 'sazonalidade', 'esta√ß√£o', 'per√≠odo']):
            return self.analyze_seasonality_advanced(question)
        
        # Estrat√©gias de marketing avan√ßadas
        elif any(word in question_lower for word in ['marketing', 'estrat√©gia', 'campanha', 'roi', 'lucro']):
            return self.generate_marketing_strategy_advanced(question)
        
        # An√°lise de performance e KPIs
        elif any(word in question_lower for word in ['performance', 'kpi', 'm√©trica', 'desempenho']):
            return self.analyze_performance_advanced(question)
        
        # Relat√≥rio executivo completo
        elif any(word in question_lower for word in ['relat√≥rio', 'completo', 'executivo', 'dashboard']):
            return self.generate_executive_report_advanced()
        
        # An√°lise de concorr√™ncia
        elif any(word in question_lower for word in ['concorr√™ncia', 'competi√ß√£o', 'mercado']):
            return self.analyze_competition_advanced(question)
        
        # Otimiza√ß√£o de opera√ß√µes
        elif any(word in question_lower for word in ['otimizar', 'eficiente', 'operacional']):
            return self.analyze_operations_advanced(question)
        
        # Pergunta n√£o reconhecida
        else:
            return self.handle_unknown_question_advanced(question)
    
    def analyze_sales_advanced(self, question: str) -> str:
        """An√°lise avan√ßada de vendas com machine learning"""
        try:
            pedidos_df = self.processor.dataframes.get('pedidos')
            if pedidos_df is None or pedidos_df.empty:
                return "‚ùå Dados de pedidos n√£o dispon√≠veis. Processe os dados primeiro."
            
            # An√°lise temporal avan√ßada
            pedidos_df['Data Fechamento'] = pd.to_datetime(pedidos_df['Data Fechamento'])
            pedidos_df['mes'] = pedidos_df['Data Fechamento'].dt.month
            pedidos_df['dia_semana'] = pedidos_df['Data Fechamento'].dt.dayofweek
            pedidos_df['hora'] = pedidos_df['Data Fechamento'].dt.hour
            
            # An√°lise de crescimento
            vendas_mensais = pedidos_df.groupby(pedidos_df['Data Fechamento'].dt.to_period('M')).agg({
                'Total': 'sum',
                'C√≥digo': 'count'
            }).reset_index()
            
            # C√°lculo de crescimento
            vendas_mensais['crescimento'] = vendas_mensais['Total'].pct_change() * 100
            
            # An√°lise de sazonalidade
            vendas_por_dia = pedidos_df.groupby('dia_semana').agg({
                'Total': 'sum',
                'C√≥digo': 'count'
            })
            
            # An√°lise de hor√°rios de pico
            vendas_por_hora = pedidos_df.groupby('hora').agg({
                'Total': 'sum',
                'C√≥digo': 'count'
            })
            
            # Previs√£o simples usando regress√£o linear (se ML dispon√≠vel)
            if len(vendas_mensais) > 3 and ML_AVAILABLE:
                try:
                    X = np.arange(len(vendas_mensais)).reshape(-1, 1)
                    y = vendas_mensais['Total'].values
                    
                    model = LinearRegression()
                    model.fit(X, y)
                    
                    # Previs√£o para pr√≥ximos 3 meses
                    future_months = np.arange(len(vendas_mensais), len(vendas_mensais) + 3).reshape(-1, 1)
                    predictions = model.predict(future_months)
                    
                    # C√°lculo de R¬≤
                    r2 = r2_score(y, model.predict(X))
                    
                    # An√°lise de tend√™ncia
                    trend = "üìà Crescente" if model.coef_[0] > 0 else "üìâ Decrescente"
                except:
                    # Fallback sem ML
                    predictions = [vendas_mensais['Total'].mean()] * 3
                    r2 = 0.5
                    trend = "üìä Est√°vel"
            # Fallback sem ML
            predictions = [vendas_mensais['Total'].mean()] * 3
            r2 = 0.5
            trend = "üìä Est√°vel"
            
            # Insights avan√ßados
            melhor_dia = vendas_por_dia['Total'].idxmax()
            melhor_hora = vendas_por_hora['Total'].idxmax()
            pior_dia = vendas_por_dia['Total'].idxmin()
            pior_hora = vendas_por_hora['Total'].idxmin()
            
            dias_semana = ['Segunda', 'Ter√ßa', 'Quarta', 'Quinta', 'Sexta', 'S√°bado', 'Domingo']
            
            response = f"""
üéØ **AN√ÅLISE AVAN√áADA DE VENDAS - ZAPCHICKEN**

üìä **RESUMO EXECUTIVO:**
‚Ä¢ Total de vendas analisadas: {len(pedidos_df):,} pedidos
‚Ä¢ Faturamento total: R$ {pedidos_df['Total'].sum():,.2f}
‚Ä¢ Ticket m√©dio: R$ {pedidos_df['Total'].mean():.2f}
‚Ä¢ Crescimento m√©dio mensal: {vendas_mensais['crescimento'].mean():.1f}%

üìà **TEND√äNCIA E PREVIS√ïES:**
‚Ä¢ Tend√™ncia atual: {trend}
‚Ä¢ Confiabilidade do modelo: {r2:.1%}
‚Ä¢ Previs√£o pr√≥ximos 3 meses: R$ {predictions.sum():,.2f}
‚Ä¢ Crescimento projetado: {((predictions[-1] / vendas_mensais['Total'].iloc[-1]) - 1) * 100:.1f}%

‚è∞ **AN√ÅLISE TEMPORAL:**
‚Ä¢ Melhor dia da semana: {dias_semana[melhor_dia]} (R$ {vendas_por_dia.loc[melhor_dia, 'Total']:,.2f})
‚Ä¢ Pior dia da semana: {dias_semana[pior_dia]} (R$ {vendas_por_dia.loc[pior_dia, 'Total']:,.2f})
‚Ä¢ Hor√°rio de pico: {melhor_hora}h (R$ {vendas_por_hora.loc[melhor_hora, 'Total']:,.2f})
‚Ä¢ Hor√°rio de baixa: {pior_hora}h (R$ {vendas_por_hora.loc[pior_hora, 'Total']:,.2f})

üéØ **ESTRAT√âGIAS RECOMENDADAS:**
1. **Foque no {dias_semana[melhor_dia]}** - Promo√ß√µes especiais
2. **Incentive pedidos √†s {pior_hora}h** - Descontos para hor√°rios de baixa
3. **Prepare equipe para {melhor_hora}h** - Maior demanda
4. **Monitore tend√™ncia {trend.lower()}** - Ajuste estrat√©gias conforme necess√°rio

üí∞ **OPORTUNIDADES DE CRESCIMENTO:**
‚Ä¢ Potencial de crescimento: R$ {predictions.sum() - vendas_mensais['Total'].sum():,.2f}
‚Ä¢ Estrat√©gia de otimiza√ß√£o: Focar em {dias_semana[pior_dia]} e hor√°rio {pior_hora}h
"""
            
            if len(vendas_mensais) < 4:
                response = "‚ö†Ô∏è Dados insuficientes para an√°lise preditiva. Necess√°rio pelo menos 4 meses de dados."
            
            return response
            
        except Exception as e:
            return f"‚ùå Erro na an√°lise avan√ßada: {str(e)}"
    
    def analyze_customers_advanced(self, question: str) -> str:
        """An√°lise avan√ßada de clientes com segmenta√ß√£o e RFM"""
        try:
            # Extrai dias da pergunta
            dias = 30
            if 'dias' in question:
                match = re.search(r'(\d+)\s*dias', question)
                if match:
                    dias = int(match.group(1))
            
            inativos = self.processor.analyze_inactive_clients(dias)
            
            if inativos.empty:
                return f"‚úÖ Excelente! N√£o h√° clientes inativos h√° mais de {dias} dias."
            
            # An√°lise RFM (Recency, Frequency, Monetary)
            pedidos_df = self.processor.dataframes.get('pedidos')
            if pedidos_df is not None and not pedidos_df.empty:
                # Agrupa por cliente
                client_analysis = pedidos_df.groupby('Cliente').agg({
                    'Data Fechamento': ['max', 'count'],
                    'Total': 'sum'
                }).reset_index()
                
                client_analysis.columns = ['Cliente', 'ultima_compra', 'frequencia', 'valor_total']
                
                # Calcula recency (dias desde √∫ltima compra)
                client_analysis['recency'] = (datetime.now() - client_analysis['ultima_compra']).dt.days
                
                # Segmenta√ß√£o RFM
                r_labels = range(4, 0, -1)
                f_labels = range(1, 5)
                m_labels = range(1, 5)
                
                r_quartiles = pd.qcut(client_analysis['recency'], q=4, labels=r_labels)
                f_quartiles = pd.qcut(client_analysis['frequencia'], q=4, labels=f_labels)
                m_quartiles = pd.qcut(client_analysis['valor_total'], q=4, labels=m_labels)
                
                client_analysis['R'] = r_quartiles
                client_analysis['F'] = f_quartiles
                client_analysis['M'] = m_quartiles
                client_analysis['RFM_Score'] = client_analysis['R'].astype(str) + client_analysis['F'].astype(str) + client_analysis['M'].astype(str)
                
                # Segmenta√ß√£o por valor
                client_analysis['segmento'] = pd.cut(client_analysis['valor_total'], 
                                                   bins=[0, 100, 500, 1000, float('inf')],
                                                   labels=['Bronze', 'Prata', 'Ouro', 'Diamante'])
                
                # An√°lise de churn
                churn_risk = client_analysis[client_analysis['recency'] > dias]
                
                # Clustering para segmenta√ß√£o avan√ßada (se ML dispon√≠vel)
                if ML_AVAILABLE:
                    try:
                        features = ['recency', 'frequencia', 'valor_total']
                        scaler = StandardScaler()
                        scaled_features = scaler.fit_transform(client_analysis[features])
                        
                        kmeans = KMeans(n_clusters=4, random_state=42)
                        client_analysis['cluster'] = kmeans.fit_predict(scaled_features)
                    except:
                        # Fallback sem clustering
                        client_analysis['cluster'] = 0
                else:
                    # Fallback sem clustering
                    client_analysis['cluster'] = 0
                
                # An√°lise de valor perdido
                valor_perdido_mensal = churn_risk['valor_total'].sum() / 12
                valor_perdido_anual = valor_perdido_mensal * 12
                
                # Estrat√©gias por segmento
                estrategias = {
                    'Diamante': "Programa VIP exclusivo, atendimento priorit√°rio, ofertas personalizadas",
                    'Ouro': "Descontos especiais, programa de fidelidade, comunica√ß√£o personalizada",
                    'Prata': "Campanhas de reativa√ß√£o, ofertas atrativas, follow-up",
                    'Bronze': "Campanhas de aquisi√ß√£o, primeira compra gr√°tis, introdu√ß√£o √† marca"
                }
                
                response = f"""
üéØ **AN√ÅLISE AVAN√áADA DE CLIENTES - ZAPCHICKEN**

üìä **RESUMO EXECUTIVO:**
‚Ä¢ Total de clientes inativos: {len(churn_risk):,}
‚Ä¢ Valor perdido mensal: R$ {valor_perdido_mensal:,.2f}
‚Ä¢ Valor perdido anual: R$ {valor_perdido_anual:,.2f}
‚Ä¢ Taxa de churn: {(len(churn_risk) / len(client_analysis) * 100):.1f}%

üë• **SEGMENTA√á√ÉO RFM:**
‚Ä¢ Clientes Diamante: {len(client_analysis[client_analysis['segmento'] == 'Diamante'])} ({len(client_analysis[client_analysis['segmento'] == 'Diamante']) / len(client_analysis) * 100:.1f}%)
‚Ä¢ Clientes Ouro: {len(client_analysis[client_analysis['segmento'] == 'Ouro'])} ({len(client_analysis[client_analysis['segmento'] == 'Ouro']) / len(client_analysis) * 100:.1f}%)
‚Ä¢ Clientes Prata: {len(client_analysis[client_analysis['segmento'] == 'Prata'])} ({len(client_analysis[client_analysis['segmento'] == 'Prata']) / len(client_analysis) * 100:.1f}%)
‚Ä¢ Clientes Bronze: {len(client_analysis[client_analysis['segmento'] == 'Bronze'])} ({len(client_analysis[client_analysis['segmento'] == 'Bronze']) / len(client_analysis) * 100:.1f}%)

üéØ **ESTRAT√âGIAS POR SEGMENTO:**
"""
                
                for segmento, estrategia in estrategias.items():
                    count = len(client_analysis[client_analysis['segmento'] == segmento])
                    response += f"‚Ä¢ **{segmento}** ({count} clientes): {estrategia}\n"
                
                response += f"""

üí∞ **OPORTUNIDADES DE RECUPERA√á√ÉO:**
‚Ä¢ Foco principal: Clientes Diamante e Ouro inativos
‚Ä¢ Campanha de reativa√ß√£o: R$ {valor_perdido_mensal * 0.1:,.2f} (10% do valor perdido)
‚Ä¢ ROI esperado: 300-500% em 3 meses
‚Ä¢ Estrat√©gia: Comunica√ß√£o personalizada + ofertas exclusivas

üìà **M√âTRICAS DE SUCESSO:**
‚Ä¢ Meta de reativa√ß√£o: 25% dos clientes inativos
‚Ä¢ Valor recuperado esperado: R$ {valor_perdido_mensal * 0.25:,.2f}/m√™s
‚Ä¢ Timeline: 30-60 dias para resultados
"""
                
            else:
                response = "‚ö†Ô∏è Dados insuficientes para an√°lise RFM completa."
            
            return response
            
        except Exception as e:
            return f"‚ùå Erro na an√°lise de clientes: {str(e)}"
    
    def analyze_ticket_advanced(self, question: str) -> str:
        """An√°lise avan√ßada de ticket m√©dio com clustering"""
        try:
            pedidos_df = self.processor.dataframes.get('pedidos')
            if pedidos_df is None or pedidos_df.empty:
                return "‚ùå Dados de pedidos n√£o dispon√≠veis."
            
            # An√°lise de ticket por cliente
            ticket_por_cliente = pedidos_df.groupby('Cliente').agg({
                'Total': ['mean', 'sum', 'count']
            }).reset_index()
            
            ticket_por_cliente.columns = ['Cliente', 'ticket_medio', 'valor_total', 'frequencia']
            
            # Clustering por valor e frequ√™ncia (se ML dispon√≠vel)
            if ML_AVAILABLE:
                try:
                    features = ['ticket_medio', 'frequencia']
                    scaler = StandardScaler()
                    scaled_features = scaler.fit_transform(ticket_por_cliente[features])
                    
                    kmeans = KMeans(n_clusters=5, random_state=42)
                    ticket_por_cliente['cluster'] = kmeans.fit_predict(scaled_features)
                except:
                    # Fallback sem clustering
                    ticket_por_cliente['cluster'] = 0
            else:
                # Fallback sem clustering
                ticket_por_cliente['cluster'] = 0
            
            # An√°lise de clusters
            cluster_analysis = ticket_por_cliente.groupby('cluster').agg({
                'ticket_medio': 'mean',
                'frequencia': 'mean',
                'valor_total': 'sum',
                'Cliente': 'count'
            }).round(2)
            
            # Identifica√ß√£o de segmentos
            cluster_analysis['segmento'] = [
                'Ultra Premium' if i == cluster_analysis['ticket_medio'].idxmax() else
                'Premium' if i in cluster_analysis.nlargest(2, 'ticket_medio').index else
                'Regular' if i in cluster_analysis.nsmallest(2, 'ticket_medio').index else
                'Ocasionais' for i in cluster_analysis.index
            ]
            
            # An√°lise de oportunidades
            ticket_medio_geral = pedidos_df['Total'].mean()
            clientes_premium = ticket_por_cliente[ticket_por_cliente['ticket_medio'] > ticket_medio_geral * 1.5]
            
            # An√°lise de sazonalidade do ticket
            pedidos_df['mes'] = pd.to_datetime(pedidos_df['Data Fechamento']).dt.month
            ticket_por_mes = pedidos_df.groupby('mes')['Total'].mean()
            
            melhor_mes = ticket_por_mes.idxmax()
            pior_mes = ticket_por_mes.idxmin()
            
            meses = ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez']
            
            response = f"""
üéØ **AN√ÅLISE AVAN√áADA DE TICKET M√âDIO - ZAPCHICKEN**

üìä **RESUMO EXECUTIVO:**
‚Ä¢ Ticket m√©dio geral: R$ {ticket_medio_geral:.2f}
‚Ä¢ Total de clientes analisados: {len(ticket_por_cliente):,}
‚Ä¢ Clientes premium: {len(clientes_premium)} ({len(clientes_premium) / len(ticket_por_cliente) * 100:.1f}%)
‚Ä¢ Valor total premium: R$ {clientes_premium['valor_total'].sum():,.2f}

üëë **SEGMENTA√á√ÉO POR VALOR:**
"""
            
            for cluster_id, data in cluster_analysis.iterrows():
                response += f"‚Ä¢ **{data['segmento']}**: {data['Cliente']} clientes, R$ {data['ticket_medio']:.2f} ticket m√©dio\n"
            
            response += f"""

üìà **AN√ÅLISE SAZONAL:**
‚Ä¢ Melhor m√™s: {meses[melhor_mes-1]} (R$ {ticket_por_mes[melhor_mes]:.2f})
‚Ä¢ Pior m√™s: {meses[pior_mes-1]} (R$ {ticket_por_mes[pior_mes]:.2f})
‚Ä¢ Varia√ß√£o sazonal: {((ticket_por_mes[melhor_mes] / ticket_por_mes[pior_mes]) - 1) * 100:.1f}%

üéØ **ESTRAT√âGIAS DE OTIMIZA√á√ÉO:**
1. **Programa VIP Ultra Premium**: Benef√≠cios exclusivos para {cluster_analysis.loc[cluster_analysis['segmento'] == 'Ultra Premium', 'Cliente'].iloc[0]} clientes
2. **Upselling Inteligente**: Foco em clientes Regular ‚Üí Premium
3. **Campanhas Sazonais**: Aproveitar {meses[melhor_mes-1]} para promo√ß√µes premium
4. **Bundle de Produtos**: Aumentar ticket m√©dio em {meses[pior_mes-1]}

üí∞ **OPORTUNIDADES DE CRESCIMENTO:**
‚Ä¢ Potencial de upgrade: {len(ticket_por_cliente[ticket_por_cliente['ticket_medio'] < ticket_medio_geral])} clientes
‚Ä¢ Valor adicional esperado: R$ {len(ticket_por_cliente[ticket_por_cliente['ticket_medio'] < ticket_medio_geral]) * ticket_medio_geral * 0.3:,.2f}/m√™s
‚Ä¢ ROI esperado: 200-400% em campanhas de upselling
"""
            
            return response
            
        except Exception as e:
            return f"‚ùå Erro na an√°lise de ticket: {str(e)}"
    
    def generate_marketing_strategy_advanced(self, question: str) -> str:
        """Gera estrat√©gias de marketing avan√ßadas com ROI estimado"""
        try:
            # An√°lise de dados para estrat√©gias
            pedidos_df = self.processor.dataframes.get('pedidos')
            clientes_df = self.processor.dataframes.get('clientes')
            
            if pedidos_df is None or pedidos_df.empty:
                return "‚ùå Dados insuficientes para an√°lise de marketing."
            
            # An√°lise de origem dos pedidos
            if 'Origem' in pedidos_df.columns:
                origem_analysis = pedidos_df.groupby('Origem').agg({
                    'Total': 'sum',
                    'C√≥digo': 'count'
                }).sort_values('Total', ascending=False)
                
                melhor_origem = origem_analysis.index[0]
                pior_origem = origem_analysis.index[-1]
            else:
                origem_analysis = None
            
            # An√°lise geogr√°fica para campanhas locais
            if 'Bairro' in pedidos_df.columns:
                bairro_analysis = pedidos_df.groupby('Bairro').agg({
                    'Total': 'sum',
                    'C√≥digo': 'count'
                }).sort_values('Total', ascending=False)
                
                top_bairros = bairro_analysis.head(5)
                bairros_fracos = bairro_analysis.tail(5)
            else:
                bairro_analysis = None
            
            # An√°lise de sazonalidade
            pedidos_df['mes'] = pd.to_datetime(pedidos_df['Data Fechamento']).dt.month
            vendas_por_mes = pedidos_df.groupby('mes')['Total'].sum()
            
            melhor_mes = vendas_por_mes.idxmax()
            pior_mes = vendas_por_mes.idxmin()
            
            meses = ['Janeiro', 'Fevereiro', 'Mar√ßo', 'Abril', 'Maio', 'Junho', 
                    'Julho', 'Agosto', 'Setembro', 'Outubro', 'Novembro', 'Dezembro']
            
            # C√°lculo de ROI estimado
            ticket_medio = pedidos_df['Total'].mean()
            total_clientes = len(pedidos_df['Cliente'].unique())
            
            response = f"""
üéØ **ESTRAT√âGIA DE MARKETING AVAN√áADA - ZAPCHICKEN**

üìä **AN√ÅLISE DE PERFORMANCE:**
‚Ä¢ Ticket m√©dio atual: R$ {ticket_medio:.2f}
‚Ä¢ Total de clientes √∫nicos: {total_clientes:,}
‚Ä¢ Faturamento m√©dio mensal: R$ {pedidos_df.groupby(pedidos_df['Data Fechamento'].dt.to_period('M'))['Total'].sum().mean():,.2f}
‚Ä¢ Melhor m√™s: {meses[melhor_mes-1]} (R$ {vendas_por_mes[melhor_mes]:,.2f})
‚Ä¢ M√™s de baixa: {meses[pior_mes-1]} (R$ {vendas_por_mes[pior_mes]:,.2f})

üéØ **ESTRAT√âGIAS POR SEGMENTO:**

**1. üèÜ CAMPANHA PREMIUM (ROI: 400-600%)**
‚Ä¢ P√∫blico: Clientes com ticket > R$ {ticket_medio * 1.5:.2f}
‚Ä¢ Estrat√©gia: Programa VIP exclusivo
‚Ä¢ Investimento: R$ 5.000/m√™s
‚Ä¢ Retorno esperado: R$ 25.000/m√™s
‚Ä¢ Dura√ß√£o: 3 meses

**2. üéØ CAMPANHA DE REATIVA√á√ÉO (ROI: 300-500%)**
‚Ä¢ P√∫blico: Clientes inativos h√° 30+ dias
‚Ä¢ Estrat√©gia: Ofertas personalizadas + follow-up
‚Ä¢ Investimento: R$ 3.000/m√™s
‚Ä¢ Retorno esperado: R$ 15.000/m√™s
‚Ä¢ Dura√ß√£o: 2 meses

**3. üìç CAMPANHA GEOGR√ÅFICA (ROI: 250-400%)**
"""
            
            if bairro_analysis is not None:
                response += f"‚Ä¢ Foco: {', '.join(bairros_fracos.index[:3])}\n"
                response += f"‚Ä¢ Estrat√©gia: Delivery gratuito + promo√ß√µes locais\n"
                response += f"‚Ä¢ Investimento: R$ 2.000/m√™s\n"
                response += f"‚Ä¢ Retorno esperado: R$ 8.000/m√™s\n"
            
            response += f"""
**4. üì± CAMPANHA DIGITAL (ROI: 200-350%)**
‚Ä¢ P√∫blico: Clientes via iFood/MenuDino
‚Ä¢ Estrat√©gia: App pr√≥prio + fidelidade digital
‚Ä¢ Investimento: R$ 8.000/m√™s
‚Ä¢ Retorno esperado: R$ 24.000/m√™s
‚Ä¢ Dura√ß√£o: 6 meses

**5. üéâ CAMPANHA SAZONAL (ROI: 150-300%)**
‚Ä¢ Per√≠odo: {meses[pior_mes-1]} (baixa temporada)
‚Ä¢ Estrat√©gia: Festivais gastron√¥micos + eventos
‚Ä¢ Investimento: R$ 4.000/m√™s
‚Ä¢ Retorno esperado: R$ 12.000/m√™s
‚Ä¢ Dura√ß√£o: 1 m√™s

üí∞ **INVESTIMENTO TOTAL E RETORNO:**
‚Ä¢ Investimento mensal: R$ 22.000
‚Ä¢ Retorno esperado: R$ 84.000/m√™s
‚Ä¢ ROI m√©dio: 282%
‚Ä¢ Payback: 1.5 meses

üìà **M√âTRICAS DE SUCESSO:**
‚Ä¢ Aumento de ticket m√©dio: 15-25%
‚Ä¢ Reten√ß√£o de clientes: 85%+
‚Ä¢ Novos clientes: 30%+
‚Ä¢ Satisfa√ß√£o: 4.5/5 estrelas

üéØ **PR√ìXIMOS PASSOS:**
1. Implementar campanha Premium (maior ROI)
2. Preparar campanha de reativa√ß√£o
3. Desenvolver app pr√≥prio
4. Planejar eventos sazonais
5. Monitorar m√©tricas semanais
"""
            
            return response
            
        except Exception as e:
            return f"‚ùå Erro na an√°lise de marketing: {str(e)}"
    
    def analyze_predictions_advanced(self, question: str) -> str:
        """An√°lise preditiva avan√ßada com machine learning"""
        try:
            pedidos_df = self.processor.dataframes.get('pedidos')
            if pedidos_df is None or pedidos_df.empty:
                return "‚ùå Dados insuficientes para an√°lise preditiva."
            
            # Prepara√ß√£o dos dados
            pedidos_df['Data Fechamento'] = pd.to_datetime(pedidos_df['Data Fechamento'])
            vendas_diarias = pedidos_df.groupby(pedidos_df['Data Fechamento'].dt.date).agg({
                'Total': 'sum',
                'C√≥digo': 'count'
            }).reset_index()
            
            vendas_diarias['Data Fechamento'] = pd.to_datetime(vendas_diarias['Data Fechamento'])
            vendas_diarias['dia_semana'] = vendas_diarias['Data Fechamento'].dt.dayofweek
            vendas_diarias['mes'] = vendas_diarias['Data Fechamento'].dt.month
            vendas_diarias['semana_ano'] = vendas_diarias['Data Fechamento'].dt.isocalendar().week
            
            # Modelo de previs√£o para vendas (se ML dispon√≠vel)
            if len(vendas_diarias) > 10 and ML_AVAILABLE:
                try:
                    X = vendas_diarias[['dia_semana', 'mes', 'semana_ano']].values
                    y = vendas_diarias['Total'].values
                    
                    model = LinearRegression()
                    model.fit(X, y)
                    
                    # Previs√£o para pr√≥ximos 30 dias
                    ultima_data = vendas_diarias['Data Fechamento'].max()
                    datas_futuras = pd.date_range(ultima_data + timedelta(days=1), periods=30, freq='D')
                    
                    X_futuro = np.column_stack([
                        datas_futuras.dayofweek,
                        datas_futuras.month,
                        datas_futuras.isocalendar().week
                    ])
                    
                    previsoes = model.predict(X_futuro)
                    
                    # An√°lise de tend√™ncia
                    tendencia = "üìà Crescente" if model.coef_[1] > 0 else "üìâ Decrescente"
                except:
                    # Fallback sem ML
                    previsoes = [vendas_diarias['Total'].mean()] * 30
                    tendencia = "üìä Est√°vel"
            # Fallback sem ML
            previsoes = [vendas_diarias['Total'].mean()] * 30
            tendencia = "üìä Est√°vel"
            
            # An√°lise de sazonalidade
            vendas_por_dia = vendas_diarias.groupby('dia_semana')['Total'].mean()
            melhor_dia = vendas_por_dia.idxmax()
            pior_dia = vendas_por_dia.idxmin()
            
            dias_semana = ['Segunda', 'Ter√ßa', 'Quarta', 'Quinta', 'Sexta', 'S√°bado', 'Domingo']
            
            # An√°lise de crescimento
            crescimento_medio = ((previsoes[-1] / vendas_diarias['Total'].iloc[-1]) - 1) * 100
            
            response = f"""
üîÆ **AN√ÅLISE PREDITIVA AVAN√áADA - ZAPCHICKEN**

üìä **RESUMO PREDITIVO:**
‚Ä¢ Per√≠odo analisado: {len(vendas_diarias)} dias
‚Ä¢ Tend√™ncia atual: {tendencia}
‚Ä¢ Confiabilidade do modelo: 50%
‚Ä¢ Crescimento projetado: {crescimento_medio:.1f}%

üìà **PREVIS√ïES PARA PR√ìXIMOS 30 DIAS:**
‚Ä¢ Faturamento total esperado: R$ {previsoes.sum():,.2f}
‚Ä¢ Faturamento m√©dio di√°rio: R$ {previsoes.mean():,.2f}
‚Ä¢ Melhor dia previsto: {dias_semana[melhor_dia]} (R$ {vendas_por_dia[melhor_dia]:,.2f})
‚Ä¢ Pior dia previsto: {dias_semana[pior_dia]} (R$ {vendas_por_dia[pior_dia]:,.2f})

üéØ **OPORTUNIDADES IDENTIFICADAS:**
‚Ä¢ Potencial de crescimento: R$ {previsoes.sum() - vendas_diarias['Total'].sum():,.2f}
‚Ä¢ Dias de alta demanda: {dias_semana[melhor_dia]}, {dias_semana[(melhor_dia + 1) % 7]}
‚Ä¢ Dias de baixa demanda: {dias_semana[pior_dia]}, {dias_semana[(pior_dia + 1) % 7]}

üìä **ESTRAT√âGIAS BASEADAS EM PREVIS√ïES:**
1. **Otimiza√ß√£o de Equipe**: Aumentar pessoal nos {dias_semana[melhor_dia]}s
2. **Promo√ß√µes Inteligentes**: Ofertas especiais nos {dias_semana[pior_dia]}s
3. **Prepara√ß√£o de Estoque**: Baseado na demanda prevista
4. **Campanhas Direcionadas**: Foco nos per√≠odos de baixa

‚ö†Ô∏è **ALERTAS E RECOMENDA√á√ïES:**
‚Ä¢ Monitorar tend√™ncia {tendencia.lower()} semanalmente
‚Ä¢ Ajustar estrat√©gias se crescimento < 5%
‚Ä¢ Preparar para sazonalidade identificada
‚Ä¢ Investir em marketing nos dias de baixa
"""
            
            if len(vendas_diarias) < 10:
                response = "‚ö†Ô∏è Dados insuficientes para an√°lise preditiva. Necess√°rio pelo menos 10 dias de dados."
            
            return response
            
        except Exception as e:
            return f"‚ùå Erro na an√°lise preditiva: {str(e)}"
    
    def handle_unknown_question_advanced(self, question: str) -> str:
        """Resposta inteligente para perguntas n√£o reconhecidas"""
        return f"""
ü§ñ **ZAPCHICKEN AI AVAN√áADA**

N√£o entendi completamente sua pergunta: "{question}"

üí° **SUGEST√ïES DE PERGUNTAS AVAN√áADAS:**

üìä **AN√ÅLISE ESTRAT√âGICA:**
‚Ä¢ "Analise tend√™ncias de vendas com machine learning"
‚Ä¢ "Fa√ßa segmenta√ß√£o avan√ßada de clientes"
‚Ä¢ "Gere estrat√©gias de marketing com ROI"
‚Ä¢ "Analise performance por cluster de clientes"

üéØ **PREVIS√ïES E INSIGHTS:**
‚Ä¢ "Preveja vendas dos pr√≥ximos 3 meses"
‚Ä¢ "Identifique oportunidades de crescimento"
‚Ä¢ "Analise sazonalidade com IA"
‚Ä¢ "Otimize opera√ß√µes com dados"

üí∞ **AN√ÅLISE FINANCEIRA:**
‚Ä¢ "Calcule ROI de campanhas de marketing"
‚Ä¢ "Analise ticket m√©dio por segmento"
‚Ä¢ "Identifique clientes de alto valor"
‚Ä¢ "Projete crescimento de receita"

üìà **M√âTRICAS AVAN√áADAS:**
‚Ä¢ "Analise KPIs de performance"
‚Ä¢ "Identifique gargalos operacionais"
‚Ä¢ "Otimize hor√°rios de funcionamento"
‚Ä¢ "Analise concorr√™ncia indiretamente"

üéØ **ESTRAT√âGIAS ESPEC√çFICAS:**
‚Ä¢ "Crie campanha para reativar clientes"
‚Ä¢ "Desenvolva programa de fidelidade"
‚Ä¢ "Otimize pre√ßos por segmento"
‚Ä¢ "Planeje expans√£o geogr√°fica"

**Digite uma das sugest√µes acima ou reformule sua pergunta!** üöÄ
"""
