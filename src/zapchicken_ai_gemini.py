import pandas as pd
import numpy as np
from typing import List, Dict, Any, Optional, Tuple
from pathlib import Path
from datetime import datetime, timedelta
import re
from collections import Counter
import warnings
import json
import requests
warnings.filterwarnings('ignore')

from .zapchicken_processor import ZapChickenProcessor

class ZapChickenAIGemini:
    """Sistema de IA com Gemini API - An√°lises Avan√ßadas e Gratuitas"""
    
    def __init__(self, processor: ZapChickenProcessor, api_key: str = None):
        self.processor = processor
        self.api_key = api_key
        self.conversation_history = []
        self.insights_cache = {}
        self.base_url = "https://generativelanguage.googleapis.com/v1/models/gemini-1.5-flash:generateContent"
        
    def process_question(self, question: str) -> str:
        """Processa pergunta usando Gemini API"""
        try:
            # Se n√£o tem API key, usa an√°lise b√°sica
            if not self.api_key:
                return self._fallback_analysis(question)
            
            # Prepara dados para o Gemini
            data_summary = self._prepare_data_summary()
            
            # Constr√≥i prompt para o Gemini
            prompt = self._build_gemini_prompt(question, data_summary)
            
            # Chama Gemini API
            response = self._call_gemini_api(prompt)
            
            return response
            
        except Exception as e:
            # Fallback para an√°lise b√°sica em caso de erro
            return self._fallback_analysis(question)
    
    def _prepare_data_summary(self) -> str:
        """Prepara resumo dos dados para o Gemini"""
        try:
            # Debug: verificar se o processador tem dados
            if not hasattr(self.processor, 'dataframes') or self.processor.dataframes is None:
                return "‚ùå Processador n√£o tem dados carregados. Processe os dados primeiro."
            
            pedidos_df = self.processor.dataframes.get('pedidos')
            itens_df = self.processor.dataframes.get('itens')
            clientes_df = self.processor.dataframes.get('clientes')
            
            # Debug: verificar quais dataframes est√£o dispon√≠veis
            available_dfs = []
            if pedidos_df is not None and not pedidos_df.empty:
                available_dfs.append(f"pedidos ({len(pedidos_df)} registros)")
            if itens_df is not None and not itens_df.empty:
                available_dfs.append(f"itens ({len(itens_df)} registros)")
            if clientes_df is not None and not clientes_df.empty:
                available_dfs.append(f"clientes ({len(clientes_df)} registros)")
            
            if not available_dfs:
                return "‚ùå Nenhum dado encontrado. Verifique se os arquivos foram processados corretamente."
            
            summary = f"üìä RESUMO DOS DADOS DA ZAPCHICKEN:\n\n"
            summary += f"üìÅ DataFrames dispon√≠veis: {', '.join(available_dfs)}\n\n"
            
            if pedidos_df is not None and not pedidos_df.empty:
                pedidos_df['Data Fechamento'] = pd.to_datetime(pedidos_df['Data Fechamento'])
                
                summary += f"üõí PEDIDOS:\n"
                summary += f"‚Ä¢ Total de pedidos: {len(pedidos_df):,}\n"
                summary += f"‚Ä¢ Receita total: R$ {pedidos_df['Total'].sum():,.2f}\n"
                summary += f"‚Ä¢ Ticket m√©dio: R$ {pedidos_df['Total'].mean():.2f}\n"
                summary += f"‚Ä¢ Per√≠odo: {pedidos_df['Data Fechamento'].min().strftime('%d/%m/%Y')} a {pedidos_df['Data Fechamento'].max().strftime('%d/%m/%Y')}\n"
                summary += f"‚Ä¢ Clientes √∫nicos: {pedidos_df['Cliente'].nunique():,}\n"
                
                # Top origens
                origem_analise = pedidos_df['Origem'].value_counts().head(3)
                summary += f"‚Ä¢ Principais origens: {origem_analise.to_dict()}\n\n"
                
                # An√°lise temporal
                vendas_diarias = pedidos_df.groupby('Data Fechamento')['Total'].sum()
                summary += f"‚Ä¢ M√©dia di√°ria: R$ {vendas_diarias.mean():.2f}\n"
                summary += f"‚Ä¢ Maior dia: R$ {vendas_diarias.max():.2f}\n"
                summary += f"‚Ä¢ Menor dia: R$ {vendas_diarias.min():.2f}\n"
                
                # An√°lise por origem
                vendas_por_origem = pedidos_df.groupby('Origem')['Total'].agg(['sum', 'count', 'mean']).round(2)
                summary += f"‚Ä¢ Vendas por origem:\n"
                for origem, data in vendas_por_origem.iterrows():
                    summary += f"  - {origem}: R$ {data['sum']:,.2f} ({data['count']} pedidos, ticket R$ {data['mean']:.2f})\n"
                
                # An√°lise mensal
                pedidos_df['Mes'] = pedidos_df['Data Fechamento'].dt.to_period('M')
                vendas_mensais = pedidos_df.groupby('Mes')['Total'].sum()
                summary += f"‚Ä¢ Vendas mensais: {vendas_mensais.to_dict()}\n\n"
            
            if itens_df is not None and not itens_df.empty:
                summary += f"üõçÔ∏è PRODUTOS:\n"
                summary += f"‚Ä¢ Total de itens vendidos: {itens_df['Qtd.'].sum():,}\n"
                
                # Verifica se as colunas existem (com tratamento para espa√ßos)
                nome_prod_col = 'Nome Prod.' if 'Nome Prod.' in itens_df.columns else 'Nome Prod'
                cat_prod_col = 'Cat. Prod.' if 'Cat. Prod.' in itens_df.columns else 'Cat. Prod'
                
                if nome_prod_col in itens_df.columns:
                    summary += f"‚Ä¢ Produtos √∫nicos: {itens_df[nome_prod_col].nunique():,}\n"
                else:
                    summary += f"‚Ä¢ Produtos √∫nicos: {itens_df.shape[0]:,}\n"
                    
                if cat_prod_col in itens_df.columns:
                    summary += f"‚Ä¢ Categorias: {itens_df[cat_prod_col].nunique():,}\n"
                else:
                    summary += f"‚Ä¢ Categorias: N/A\n"
                
                # Top produtos (se a coluna existir)
                if nome_prod_col in itens_df.columns:
                    try:
                        top_produtos = itens_df.groupby(nome_prod_col)['Qtd.'].sum().nlargest(10)
                        summary += f"‚Ä¢ Top 10 produtos por quantidade:\n"
                        for i, (produto, qtd) in enumerate(top_produtos.items(), 1):
                            summary += f"  {i}. {produto}: {qtd} unidades\n"
                    except:
                        summary += f"‚Ä¢ Top produtos: Erro ao processar\n"
                else:
                    summary += f"‚Ä¢ Top produtos: Coluna n√£o encontrada\n"
                
                # Top produtos por valor
                try:
                    itens_df['Valor Total'] = itens_df['Qtd.'] * itens_df['Valor Un. Item']
                    top_produtos_valor = itens_df.groupby(nome_prod_col)['Valor Total'].sum().nlargest(5)
                    summary += f"‚Ä¢ Top 5 produtos por valor:\n"
                    for i, (produto, valor) in enumerate(top_produtos_valor.items(), 1):
                        summary += f"  {i}. {produto}: R$ {valor:,.2f}\n"
                except:
                    summary += f"‚Ä¢ Top produtos por valor: Erro ao processar\n"
                
                summary += "\n"
            
            if clientes_df is not None and not clientes_df.empty:
                summary += f"üë• CLIENTES:\n"
                summary += f"‚Ä¢ Total de clientes: {len(clientes_df):,}\n"
                
                # An√°lise de bairros
                if 'Bairro' in clientes_df.columns:
                    top_bairros = clientes_df['Bairro'].value_counts().head(5)
                    summary += f"‚Ä¢ Top 5 bairros: {top_bairros.to_dict()}\n"
                
                # Top clientes por valor gasto
                try:
                    clientes_por_valor = pedidos_df.groupby('Cliente')['Total'].sum().nlargest(10)
                    summary += f"‚Ä¢ Top 10 clientes por valor gasto:\n"
                    for i, (cliente, valor) in enumerate(clientes_por_valor.items(), 1):
                        summary += f"  {i}. {cliente}: R$ {valor:,.2f}\n"
                except:
                    summary += f"‚Ä¢ Top clientes: Erro ao processar\n"
                
                # An√°lise de frequ√™ncia de compra
                try:
                    freq_compra = pedidos_df['Cliente'].value_counts()
                    summary += f"‚Ä¢ An√°lise de frequ√™ncia:\n"
                    summary += f"  - Clientes com 1 pedido: {len(freq_compra[freq_compra == 1])}\n"
                    summary += f"  - Clientes com 2-5 pedidos: {len(freq_compra[(freq_compra >= 2) & (freq_compra <= 5)])}\n"
                    summary += f"  - Clientes com 6+ pedidos: {len(freq_compra[freq_compra >= 6])}\n"
                except:
                    summary += f"‚Ä¢ An√°lise de frequ√™ncia: Erro ao processar\n"
                
                summary += "\n"
            
            return summary
            
        except Exception as e:
            return f"‚ùå Erro ao preparar dados: {str(e)}"
    
    def _build_gemini_prompt(self, question: str, data_summary: str) -> str:
        """Constr√≥i prompt otimizado para o Gemini"""
        
        system_prompt = f"""
Voc√™ √© um especialista em Business Intelligence e an√°lise de dados para restaurantes/food service. 
Voc√™ est√° analisando dados da ZapChicken, um neg√≥cio de delivery de comida.

IMPORTANTE: Use APENAS os dados fornecidos abaixo. N√ÉO fa√ßa suposi√ß√µes ou estimativas. 
Se os dados n√£o estiverem dispon√≠veis, diga claramente "Dados n√£o dispon√≠veis".

DADOS DISPON√çVEIS:
{data_summary}

INSTRU√á√ïES ESPEC√çFICAS:
1. Use EXATAMENTE os n√∫meros e dados fornecidos acima
2. N√ÉO fa√ßa estimativas ou suposi√ß√µes
3. Se pedir dados espec√≠ficos que n√£o est√£o na lista, diga "Dados n√£o dispon√≠veis"
4. Apresente os dados em formato de tabela quando poss√≠vel
5. Use os valores reais dos dados fornecidos
6. Seja preciso e espec√≠fico com os n√∫meros
7. Use emojis para tornar a resposta visual
8. Estruture com t√≠tulos claros
9. Formate valores monet√°rios com R$ e separadores de milhares
10. Use formata√ß√£o markdown para tabelas bem estruturadas
11. Adicione insights estrat√©gicos baseados nos dados
12. Use cores e formata√ß√£o para destacar informa√ß√µes importantes

PERGUNTA DO USU√ÅRIO: {question}

FORMATA√á√ÉO ESPEC√çFICA:
- Use tabelas markdown bem estruturadas
- Formate valores monet√°rios: R$ 1.234,56
- Use emojis para categorias: üõí Pedidos, üõçÔ∏è Produtos, üë• Clientes, üí∞ Financeiro
- Adicione insights estrat√©gicos ap√≥s cada tabela
- Use **negrito** para destacar valores importantes
- Estruture com t√≠tulos claros usando ###

EXEMPLO DE FORMATA√á√ÉO:
### üí∞ Resumo Financeiro
| M√™s | Receita Total |
|-----|---------------|
| Fevereiro/2025 | **R$ 30.118,61** |
| Mar√ßo/2025 | **R$ 41.458,60** |

**üí° Insight:** Mar√ßo foi o m√™s com maior receita, com crescimento de 37,6% em rela√ß√£o a fevereiro.

### üõí Top Produtos
| Produto | Quantidade | Valor |
|---------|------------|-------|
| Produto A | 500 | **R$ 25.000,00** |

**üí° Insight:** Este produto representa 15% da receita total.

INSIGHTS ESTRAT√âGICOS A INCLUIR:
- üéØ **Oportunidades:** Identifique produtos/clientes com potencial
- üìà **Tend√™ncias:** Analise crescimento/queda nos dados
- üí° **Recomenda√ß√µes:** Sugira a√ß√µes espec√≠ficas baseadas nos dados
- ‚ö†Ô∏è **Alertas:** Destaque pontos de aten√ß√£o
- üöÄ **Estrat√©gias:** Proponha melhorias baseadas nos insights

IMPORTANTE: Responda usando APENAS os dados fornecidos. Se algo n√£o estiver nos dados, diga claramente.
"""
        
        return system_prompt
    
    def _call_gemini_api(self, prompt: str) -> str:
        """Chama a API do Gemini"""
        try:
            headers = {
                'Content-Type': 'application/json',
            }
            
            data = {
                "contents": [{
                    "parts": [{
                        "text": prompt
                    }]
                }],
                "generationConfig": {
                    "temperature": 0.7,
                    "topK": 40,
                    "topP": 0.95,
                    "maxOutputTokens": 2048,
                }
            }
            
            url = f"{self.base_url}?key={self.api_key}"
            
            response = requests.post(url, headers=headers, json=data, timeout=30)
            
            if response.status_code == 200:
                result = response.json()
                if 'candidates' in result and len(result['candidates']) > 0:
                    return result['candidates'][0]['content']['parts'][0]['text']
                else:
                    return "‚ùå Resposta vazia da API Gemini"
            else:
                return f"‚ùå Erro na API Gemini: {response.status_code} - {response.text}"
                
        except Exception as e:
            return f"‚ùå Erro ao chamar Gemini API: {str(e)}"
    
    def _fallback_analysis(self, question: str) -> str:
        """An√°lise b√°sica quando Gemini n√£o est√° dispon√≠vel"""
        try:
            pedidos_df = self.processor.dataframes.get('pedidos')
            if pedidos_df is None or pedidos_df.empty:
                return "‚ùå Dados n√£o dispon√≠veis. Processe os dados primeiro."
            
            question_lower = question.lower()
            
            # An√°lise b√°sica baseada em palavras-chave
            if any(word in question_lower for word in ['venda', 'comprou', 'pedido']):
                total_vendas = pedidos_df['Total'].sum()
                ticket_medio = pedidos_df['Total'].mean()
                return f"""
üìä **AN√ÅLISE B√ÅSICA DE VENDAS**

‚Ä¢ Total de Vendas: R$ {total_vendas:,.2f}
‚Ä¢ Ticket M√©dio: R$ {ticket_medio:.2f}
‚Ä¢ Total de Pedidos: {len(pedidos_df):,}

üí° **Para an√°lises mais avan√ßadas, configure uma API key do Gemini!**
"""
            
            elif any(word in question_lower for word in ['cliente', 'inativo']):
                total_clientes = pedidos_df['Cliente'].nunique()
                return f"""
üë• **AN√ÅLISE B√ÅSICA DE CLIENTES**

‚Ä¢ Total de Clientes √önicos: {total_clientes:,}
‚Ä¢ Pedidos por Cliente: {len(pedidos_df) / total_clientes:.1f}

üí° **Para an√°lise RFM e segmenta√ß√£o, configure uma API key do Gemini!**
"""
            
            else:
                return f"""
ü§ñ **IA ZapChicken - Modo B√°sico**

Pergunta: "{question}"

üìä **Dados Dispon√≠veis:**
‚Ä¢ {len(pedidos_df):,} pedidos processados
‚Ä¢ R$ {pedidos_df['Total'].sum():,.2f} em vendas totais

üí° **Para an√°lises avan√ßadas com IA, configure uma API key do Gemini!**

üîß **Como configurar:**
1. Acesse: https://makersuite.google.com/app/apikey
2. Crie uma API key gratuita
3. Configure na aplica√ß√£o
4. Desfrute de an√°lises muito mais inteligentes!
"""
                
        except Exception as e:
            return f"‚ùå Erro na an√°lise b√°sica: {str(e)}"
    
    def set_api_key(self, api_key: str):
        """Define a API key do Gemini"""
        self.api_key = api_key
        return "‚úÖ API key do Gemini configurada com sucesso!"
    
    def get_api_status(self) -> str:
        """Verifica status da API"""
        if not self.api_key:
            return "‚ùå API key n√£o configurada"
        
        try:
            # Teste simples da API
            test_prompt = "Responda apenas: 'API funcionando'"
            response = self._call_gemini_api(test_prompt)
            
            if "API funcionando" in response:
                return "‚úÖ API Gemini funcionando perfeitamente"
            else:
                return f"‚ö†Ô∏è API respondeu, mas inesperadamente: {response[:100]}..."
                
        except Exception as e:
            return f"‚ùå Erro na API: {str(e)}"
    
    def get_data_status(self) -> str:
        """Verifica status dos dados carregados"""
        try:
            if not hasattr(self.processor, 'dataframes') or self.processor.dataframes is None:
                return "‚ùå Processador n√£o tem dados carregados"
            
            pedidos_df = self.processor.dataframes.get('pedidos')
            itens_df = self.processor.dataframes.get('itens')
            clientes_df = self.processor.dataframes.get('clientes')
            
            status = []
            if pedidos_df is not None and not pedidos_df.empty:
                status.append(f"‚úÖ Pedidos: {len(pedidos_df)} registros")
            else:
                status.append("‚ùå Pedidos: n√£o encontrado")
                
            if itens_df is not None and not itens_df.empty:
                status.append(f"‚úÖ Itens: {len(itens_df)} registros")
            else:
                status.append("‚ùå Itens: n√£o encontrado")
                
            if clientes_df is not None and not clientes_df.empty:
                status.append(f"‚úÖ Clientes: {len(clientes_df)} registros")
            else:
                status.append("‚ùå Clientes: n√£o encontrado")
            
            return "\n".join(status)
            
        except Exception as e:
            return f"‚ùå Erro ao verificar dados: {str(e)}"
