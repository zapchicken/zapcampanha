import pandas as pd
import numpy as np
from typing import List, Dict, Any, Optional, Tuple
from pathlib import Path
from datetime import datetime, timedelta
import re
from collections import Counter
import warnings
warnings.filterwarnings('ignore')

from .zapchicken_processor import ZapChickenProcessor

class ZapChickenAIVercel:
    """Sistema de IA Ultra-Leve para Vercel - Sem Machine Learning"""
    
    def __init__(self, processor: ZapChickenProcessor):
        self.processor = processor
        self.conversation_history = []
        self.insights_cache = {}
        
    def process_question(self, question: str) -> str:
        """Processa pergunta com an√°lise estat√≠stica avan√ßada"""
        question_lower = question.lower()
        
        # An√°lise de vendas
        if any(word in question_lower for word in ['comprou', 'vendeu', 'venda', 'pedido', 'data']):
            return self.analyze_sales_vercel(question)
        
        # An√°lise de clientes
        elif any(word in question_lower for word in ['inativo', 'inatividade', 'reativar', 'cliente']):
            return self.analyze_customers_vercel(question)
        
        # An√°lise de ticket m√©dio
        elif any(word in question_lower for word in ['ticket', 'm√©dio', 'alto', 'premium', 'valor']):
            return self.analyze_ticket_vercel(question)
        
        # An√°lise geogr√°fica
        elif any(word in question_lower for word in ['bairro', 'cidade', 'local', 'geogr√°fico', 'regi√£o']):
            return self.analyze_geographic_vercel(question)
        
        # An√°lise de produtos
        elif any(word in question_lower for word in ['produto', 'item', 'mais vendido', 'categoria']):
            return self.analyze_products_vercel(question)
        
        # Previs√µes e tend√™ncias
        elif any(word in question_lower for word in ['tend√™ncia', 'previs√£o', 'futuro', 'crescimento', 'predi√ß√£o']):
            return self.analyze_predictions_vercel(question)
        
        # An√°lise de sazonalidade
        elif any(word in question_lower for word in ['sazonal', 'sazonalidade', 'esta√ß√£o', 'per√≠odo']):
            return self.analyze_seasonality_vercel(question)
        
        # Estrat√©gias de marketing
        elif any(word in question_lower for word in ['marketing', 'estrat√©gia', 'campanha', 'roi', 'lucro']):
            return self.generate_marketing_strategy_vercel(question)
        
        # Relat√≥rio executivo
        elif any(word in question_lower for word in ['relat√≥rio', 'completo', 'executivo', 'dashboard']):
            return self.generate_executive_report_vercel()
        
        # Pergunta n√£o reconhecida
        else:
            return self.handle_unknown_question_vercel(question)
    
    def analyze_sales_vercel(self, question: str) -> str:
        """An√°lise avan√ßada de vendas sem ML"""
        try:
            pedidos_df = self.processor.dataframes.get('pedidos')
            if pedidos_df is None or pedidos_df.empty:
                return "‚ùå Dados de pedidos n√£o dispon√≠veis. Processe os dados primeiro."
            
            # An√°lise temporal
            pedidos_df['Data Fechamento'] = pd.to_datetime(pedidos_df['Data Fechamento'])
            vendas_diarias = pedidos_df.groupby('Data Fechamento')['Total'].sum().reset_index()
            vendas_mensais = pedidos_df.groupby(pedidos_df['Data Fechamento'].dt.to_period('M'))['Total'].sum()
            
            # Estat√≠sticas b√°sicas
            total_vendas = pedidos_df['Total'].sum()
            ticket_medio = pedidos_df['Total'].mean()
            total_pedidos = len(pedidos_df)
            
            # An√°lise de crescimento
            if len(vendas_mensais) > 1:
                crescimento = ((vendas_mensais.iloc[-1] - vendas_mensais.iloc[-2]) / vendas_mensais.iloc[-2]) * 100
                tendencia = "üìà Crescente" if crescimento > 0 else "üìâ Decrescente"
            else:
                crescimento = 0
                tendencia = "‚û°Ô∏è Est√°vel"
            
            # An√°lise por origem
            origem_analise = pedidos_df['Origem'].value_counts()
            origem_principal = origem_analise.index[0] if not origem_analise.empty else "N/A"
            
            # An√°lise de hor√°rios
            pedidos_df['Hora'] = pedidos_df['Data Fechamento'].dt.hour
            hora_pico = pedidos_df['Hora'].mode().iloc[0] if not pedidos_df['Hora'].mode().empty else 0
            
            response = f"""
üéØ **AN√ÅLISE AVAN√áADA DE VENDAS**

üìä **M√©tricas Principais:**
‚Ä¢ Total de Vendas: R$ {total_vendas:,.2f}
‚Ä¢ Ticket M√©dio: R$ {ticket_medio:.2f}
‚Ä¢ Total de Pedidos: {total_pedidos:,}
‚Ä¢ Crescimento Mensal: {crescimento:.1f}% ({tendencia})

üìà **An√°lise Temporal:**
‚Ä¢ Per√≠odo Analisado: {pedidos_df['Data Fechamento'].min().strftime('%d/%m/%Y')} a {pedidos_df['Data Fechamento'].max().strftime('%d/%m/%Y')}
‚Ä¢ M√©dia Di√°ria: R$ {vendas_diarias['Total'].mean():.2f}
‚Ä¢ Hora de Pico: {hora_pico}h

üõí **An√°lise por Origem:**
‚Ä¢ Origem Principal: {origem_principal}
‚Ä¢ Distribui√ß√£o: {origem_analise.head(3).to_dict()}

üí° **Insights Estrat√©gicos:**
‚Ä¢ Foque em {origem_principal} para maximizar vendas
‚Ä¢ Hor√°rio de pico: {hora_pico}h - otimize opera√ß√µes
‚Ä¢ Ticket m√©dio pode ser melhorado com upselling
"""
            
            return response
            
        except Exception as e:
            return f"‚ùå Erro na an√°lise de vendas: {str(e)}"
    
    def analyze_customers_vercel(self, question: str) -> str:
        """An√°lise avan√ßada de clientes sem ML"""
        try:
            pedidos_df = self.processor.dataframes.get('pedidos')
            if pedidos_df is None or pedidos_df.empty:
                return "‚ùå Dados de pedidos n√£o dispon√≠veis. Processe os dados primeiro."
            
            # RFM Analysis (sem ML)
            hoje = datetime.now()
            pedidos_df['Data Fechamento'] = pd.to_datetime(pedidos_df['Data Fechamento'])
            
            client_analysis = pedidos_df.groupby('Cliente').agg({
                'Data Fechamento': 'max',
                'C√≥digo': 'count',
                'Total': 'sum'
            }).reset_index()
            
            client_analysis.columns = ['cliente', 'ultima_compra', 'frequencia', 'valor_total']
            client_analysis['recency'] = (hoje - client_analysis['ultima_compra']).dt.days
            client_analysis['ticket_medio'] = client_analysis['valor_total'] / client_analysis['frequencia']
            
            # Segmenta√ß√£o manual
            def segmentar_cliente(row):
                if row['recency'] <= 30 and row['frequencia'] >= 3 and row['valor_total'] >= 500:
                    return 'Diamante'
                elif row['recency'] <= 60 and row['frequencia'] >= 2 and row['valor_total'] >= 300:
                    return 'Ouro'
                elif row['recency'] <= 90 and row['frequencia'] >= 1 and row['valor_total'] >= 150:
                    return 'Prata'
                else:
                    return 'Bronze'
            
            client_analysis['segmento'] = client_analysis.apply(segmentar_cliente, axis=1)
            
            # Estat√≠sticas
            total_clientes = len(client_analysis)
            clientes_inativos = len(client_analysis[client_analysis['recency'] > 90])
            clientes_premium = len(client_analysis[client_analysis['segmento'].isin(['Diamante', 'Ouro'])])
            
            # An√°lise de churn
            churn_rate = (clientes_inativos / total_clientes) * 100 if total_clientes > 0 else 0
            
            # Valor perdido
            valor_perdido = client_analysis[client_analysis['recency'] > 90]['valor_total'].sum()
            
            response = f"""
üë• **AN√ÅLISE AVAN√áADA DE CLIENTES**

üìä **Segmenta√ß√£o RFM:**
‚Ä¢ Total de Clientes: {total_clientes:,}
‚Ä¢ Clientes Premium (Ouro/Diamante): {clientes_premium:,} ({clientes_premium/total_clientes*100:.1f}%)
‚Ä¢ Clientes Inativos (>90 dias): {clientes_inativos:,} ({churn_rate:.1f}%)

üí∞ **An√°lise de Valor:**
‚Ä¢ Valor Total dos Clientes: R$ {client_analysis['valor_total'].sum():,.2f}
‚Ä¢ Valor Perdido (Inativos): R$ {valor_perdido:,.2f}
‚Ä¢ Ticket M√©dio por Cliente: R$ {client_analysis['valor_total'].mean():.2f}

üèÜ **Distribui√ß√£o por Segmento:**
{client_analysis['segmento'].value_counts().to_string()}

‚ö†Ô∏è **Alertas Estrat√©gicos:**
‚Ä¢ Taxa de Churn: {churn_rate:.1f}% - A√ß√£o necess√°ria!
‚Ä¢ {clientes_inativos} clientes precisam de reativa√ß√£o
‚Ä¢ Potencial de recupera√ß√£o: R$ {valor_perdido:,.2f}

üéØ **Recomenda√ß√µes:**
‚Ä¢ Campanha de reativa√ß√£o para {clientes_inativos} clientes inativos
‚Ä¢ Programa de fidelidade para clientes Prata
‚Ä¢ VIP para clientes Diamante/Ouro
"""
            
            return response
            
        except Exception as e:
            return f"‚ùå Erro na an√°lise de clientes: {str(e)}"
    
    def analyze_ticket_vercel(self, question: str) -> str:
        """An√°lise de ticket m√©dio sem ML"""
        try:
            pedidos_df = self.processor.dataframes.get('pedidos')
            if pedidos_df is None or pedidos_df.empty:
                return "‚ùå Dados de pedidos n√£o dispon√≠veis. Processe os dados primeiro."
            
            # An√°lise por cliente
            ticket_por_cliente = pedidos_df.groupby('Cliente').agg({
                'Total': ['sum', 'mean', 'count']
            }).reset_index()
            ticket_por_cliente.columns = ['cliente', 'valor_total', 'ticket_medio', 'frequencia']
            
            # Segmenta√ß√£o manual por ticket
            def segmentar_ticket(row):
                if row['ticket_medio'] >= 100:
                    return 'Ultra Premium'
                elif row['ticket_medio'] >= 70:
                    return 'Premium'
                elif row['ticket_medio'] >= 50:
                    return 'Regular'
                else:
                    return 'Ocasionais'
            
            ticket_por_cliente['segmento_ticket'] = ticket_por_cliente.apply(segmentar_ticket, axis=1)
            
            # Estat√≠sticas
            ticket_geral = pedidos_df['Total'].mean()
            ticket_mediana = pedidos_df['Total'].median()
            ticket_max = pedidos_df['Total'].max()
            ticket_min = pedidos_df['Total'].min()
            
            # An√°lise sazonal
            pedidos_df['Data Fechamento'] = pd.to_datetime(pedidos_df['Data Fechamento'])
            pedidos_df['Mes'] = pedidos_df['Data Fechamento'].dt.month
            ticket_por_mes = pedidos_df.groupby('Mes')['Total'].mean()
            
            mes_maior_ticket = ticket_por_mes.idxmax()
            mes_menor_ticket = ticket_por_mes.idxmin()
            
            response = f"""
üí∞ **AN√ÅLISE AVAN√áADA DE TICKET M√âDIO**

üìä **M√©tricas Gerais:**
‚Ä¢ Ticket M√©dio Geral: R$ {ticket_geral:.2f}
‚Ä¢ Ticket Mediano: R$ {ticket_mediana:.2f}
‚Ä¢ Maior Pedido: R$ {ticket_max:.2f}
‚Ä¢ Menor Pedido: R$ {ticket_min:.2f}

üèÜ **Segmenta√ß√£o por Ticket:**
{ticket_por_cliente['segmento_ticket'].value_counts().to_string()}

üìà **An√°lise Sazonal:**
‚Ä¢ M√™s com Maior Ticket: {mes_maior_ticket} (R$ {ticket_por_mes.max():.2f})
‚Ä¢ M√™s com Menor Ticket: {mes_menor_ticket} (R$ {ticket_por_mes.min():.2f})
‚Ä¢ Varia√ß√£o Sazonal: {((ticket_por_mes.max() - ticket_por_mes.min()) / ticket_por_mes.min() * 100):.1f}%

üí° **Insights Estrat√©gicos:**
‚Ä¢ {len(ticket_por_cliente[ticket_por_cliente['segmento_ticket'] == 'Ultra Premium'])} clientes Ultra Premium
‚Ä¢ Potencial de upselling: R$ {ticket_por_cliente[ticket_por_cliente['ticket_medio'] < 50]['valor_total'].sum():,.2f}
‚Ä¢ Foque em {mes_maior_ticket} para campanhas premium
"""
            
            return response
            
        except Exception as e:
            return f"‚ùå Erro na an√°lise de ticket: {str(e)}"
    
    def analyze_geographic_vercel(self, question: str) -> str:
        """An√°lise geogr√°fica sem ML"""
        try:
            pedidos_df = self.processor.dataframes.get('pedidos')
            if pedidos_df is None or pedidos_df.empty:
                return "‚ùå Dados de pedidos n√£o dispon√≠veis. Processe os dados primeiro."
            
            # An√°lise por bairro
            bairro_analise = pedidos_df.groupby('Bairro').agg({
                'Total': ['sum', 'count', 'mean']
            }).reset_index()
            bairro_analise.columns = ['bairro', 'valor_total', 'quantidade_pedidos', 'ticket_medio']
            
            # Top bairros
            top_bairros_valor = bairro_analise.nlargest(5, 'valor_total')
            top_bairros_pedidos = bairro_analise.nlargest(5, 'quantidade_pedidos')
            
            # An√°lise por cidade
            cidade_analise = pedidos_df.groupby('Cidade').agg({
                'Total': ['sum', 'count']
            }).reset_index()
            cidade_analise.columns = ['cidade', 'valor_total', 'quantidade_pedidos']
            
            response = f"""
üó∫Ô∏è **AN√ÅLISE GEOGR√ÅFICA AVAN√áADA**

üèÜ **Top 5 Bairros por Valor:**
{top_bairros_valor[['bairro', 'valor_total', 'quantidade_pedidos']].to_string(index=False)}

üìä **Top 5 Bairros por Pedidos:**
{top_bairros_pedidos[['bairro', 'quantidade_pedidos', 'valor_total']].to_string(index=False)}

üåÜ **An√°lise por Cidade:**
{cidade_analise.to_string(index=False)}

üí° **Insights Estrat√©gicos:**
‚Ä¢ Bairro mais lucrativo: {top_bairros_valor.iloc[0]['bairro']} (R$ {top_bairros_valor.iloc[0]['valor_total']:,.2f})
‚Ä¢ Bairro com mais pedidos: {top_bairros_pedidos.iloc[0]['bairro']} ({top_bairros_pedidos.iloc[0]['quantidade_pedidos']} pedidos)
‚Ä¢ Foque marketing em {top_bairros_valor.iloc[0]['bairro']} para maximizar receita
"""
            
            return response
            
        except Exception as e:
            return f"‚ùå Erro na an√°lise geogr√°fica: {str(e)}"
    
    def analyze_products_vercel(self, question: str) -> str:
        """An√°lise de produtos sem ML"""
        try:
            itens_df = self.processor.dataframes.get('itens')
            if itens_df is None or itens_df.empty:
                return "‚ùå Dados de itens n√£o dispon√≠veis. Processe os dados primeiro."
            
            # An√°lise por produto
            produto_analise = itens_df.groupby('Nome Prod.').agg({
                'Qtd.': 'sum',
                'Valor Tot. Item': 'sum'
            }).reset_index()
            produto_analise.columns = ['produto', 'quantidade_vendida', 'valor_total']
            
            # Top produtos
            top_produtos_qtd = produto_analise.nlargest(10, 'quantidade_vendida')
            top_produtos_valor = produto_analise.nlargest(10, 'valor_total')
            
            # An√°lise por categoria
            categoria_analise = itens_df.groupby('Cat. Prod.').agg({
                'Qtd.': 'sum',
                'Valor Tot. Item': 'sum'
            }).reset_index()
            categoria_analise.columns = ['categoria', 'quantidade_vendida', 'valor_total']
            
            response = f"""
üõçÔ∏è **AN√ÅLISE AVAN√áADA DE PRODUTOS**

üèÜ **Top 10 Produtos por Quantidade:**
{top_produtos_qtd[['produto', 'quantidade_vendida', 'valor_total']].to_string(index=False)}

üí∞ **Top 10 Produtos por Valor:**
{top_produtos_valor[['produto', 'valor_total', 'quantidade_vendida']].to_string(index=False)}

üìä **An√°lise por Categoria:**
{categoria_analise.to_string(index=False)}

üí° **Insights Estrat√©gicos:**
‚Ä¢ Produto mais vendido: {top_produtos_qtd.iloc[0]['produto']} ({top_produtos_qtd.iloc[0]['quantidade_vendida']} unidades)
‚Ä¢ Produto mais lucrativo: {top_produtos_valor.iloc[0]['produto']} (R$ {top_produtos_valor.iloc[0]['valor_total']:,.2f})
‚Ä¢ Categoria mais vendida: {categoria_analise.loc[categoria_analise['quantidade_vendida'].idxmax(), 'categoria']}
"""
            
            return response
            
        except Exception as e:
            return f"‚ùå Erro na an√°lise de produtos: {str(e)}"
    
    def analyze_predictions_vercel(self, question: str) -> str:
        """An√°lise preditiva simples sem ML"""
        try:
            pedidos_df = self.processor.dataframes.get('pedidos')
            if pedidos_df is None or pedidos_df.empty:
                return "‚ùå Dados de pedidos n√£o dispon√≠veis. Processe os dados primeiro."
            
            # An√°lise de tend√™ncia simples
            pedidos_df['Data Fechamento'] = pd.to_datetime(pedidos_df['Data Fechamento'])
            vendas_diarias = pedidos_df.groupby('Data Fechamento')['Total'].sum().reset_index()
            
            if len(vendas_diarias) < 7:
                return "‚ùå Dados insuficientes para an√°lise preditiva (m√≠nimo 7 dias)"
            
            # Tend√™ncia simples
            vendas_recentes = vendas_diarias.tail(7)
            vendas_anteriores = vendas_diarias.tail(14).head(7)
            
            media_recente = vendas_recentes['Total'].mean()
            media_anterior = vendas_anteriores['Total'].mean()
            
            tendencia = ((media_recente - media_anterior) / media_anterior) * 100 if media_anterior > 0 else 0
            
            # Previs√£o simples
            previsao_30_dias = media_recente * 30
            
            response = f"""
üîÆ **AN√ÅLISE PREDITIVA SIMPLES**

üìä **An√°lise de Tend√™ncia:**
‚Ä¢ M√©dia √öltimos 7 dias: R$ {media_recente:.2f}
‚Ä¢ M√©dia 7 dias anteriores: R$ {media_anterior:.2f}
‚Ä¢ Tend√™ncia: {tendencia:+.1f}% ({'üìà Crescente' if tendencia > 0 else 'üìâ Decrescente' if tendencia < 0 else '‚û°Ô∏è Est√°vel'})

üéØ **Previs√£o para Pr√≥ximos 30 dias:**
‚Ä¢ Receita Estimada: R$ {previsao_30_dias:,.2f}
‚Ä¢ Pedidos Estimados: {int(previsao_30_dias / vendas_diarias['Total'].mean())}

‚ö†Ô∏è **Limita√ß√µes:**
‚Ä¢ An√°lise baseada em m√©dia m√≥vel simples
‚Ä¢ N√£o considera sazonalidade complexa
‚Ä¢ Para an√°lise mais precisa, use dados hist√≥ricos maiores

üí° **Recomenda√ß√µes:**
‚Ä¢ {'Aumente estoque e equipe' if tendencia > 5 else 'Mantenha opera√ß√£o atual' if tendencia > -5 else 'Analise causas da queda'}
‚Ä¢ Prepare-se para {previsao_30_dias:,.0f} em receita
"""
            
            return response
            
        except Exception as e:
            return f"‚ùå Erro na an√°lise preditiva: {str(e)}"
    
    def analyze_seasonality_vercel(self, question: str) -> str:
        """An√°lise de sazonalidade sem ML"""
        try:
            pedidos_df = self.processor.dataframes.get('pedidos')
            if pedidos_df is None or pedidos_df.empty:
                return "‚ùå Dados de pedidos n√£o dispon√≠veis. Processe os dados primeiro."
            
            pedidos_df['Data Fechamento'] = pd.to_datetime(pedidos_df['Data Fechamento'])
            
            # An√°lise por dia da semana
            pedidos_df['Dia Semana'] = pedidos_df['Data Fechamento'].dt.day_name()
            vendas_dia_semana = pedidos_df.groupby('Dia Semana')['Total'].sum()
            
            # An√°lise por m√™s
            pedidos_df['Mes'] = pedidos_df['Data Fechamento'].dt.month
            vendas_mes = pedidos_df.groupby('Mes')['Total'].sum()
            
            # An√°lise por hora
            pedidos_df['Hora'] = pedidos_df['Data Fechamento'].dt.hour
            vendas_hora = pedidos_df.groupby('Hora')['Total'].sum()
            
            response = f"""
üìÖ **AN√ÅLISE DE SAZONALIDADE**

üìä **Vendas por Dia da Semana:**
{vendas_dia_semana.to_string()}

üìà **Vendas por M√™s:**
{vendas_mes.to_string()}

üïê **Vendas por Hora:**
{vendas_hora.to_string()}

üí° **Insights Sazonais:**
‚Ä¢ Melhor dia: {vendas_dia_semana.idxmax()} (R$ {vendas_dia_semana.max():,.2f})
‚Ä¢ Pior dia: {vendas_dia_semana.idxmin()} (R$ {vendas_dia_semana.min():,.2f})
‚Ä¢ Hora de pico: {vendas_hora.idxmax()}h (R$ {vendas_hora.max():,.2f})
‚Ä¢ Varia√ß√£o semanal: {((vendas_dia_semana.max() - vendas_dia_semana.min()) / vendas_dia_semana.min() * 100):.1f}%
"""
            
            return response
            
        except Exception as e:
            return f"‚ùå Erro na an√°lise de sazonalidade: {str(e)}"
    
    def generate_marketing_strategy_vercel(self, question: str) -> str:
        """Estrat√©gias de marketing sem ML"""
        try:
            pedidos_df = self.processor.dataframes.get('pedidos')
            if pedidos_df is None or pedidos_df.empty:
                return "‚ùå Dados de pedidos n√£o dispon√≠veis. Processe os dados primeiro."
            
            # An√°lise b√°sica para estrat√©gias
            total_vendas = pedidos_df['Total'].sum()
            ticket_medio = pedidos_df['Total'].mean()
            total_clientes = pedidos_df['Cliente'].nunique()
            
            # Clientes inativos
            hoje = datetime.now()
            pedidos_df['Data Fechamento'] = pd.to_datetime(pedidos_df['Data Fechamento'])
            clientes_inativos = pedidos_df.groupby('Cliente')['Data Fechamento'].max()
            clientes_inativos = clientes_inativos[(hoje - clientes_inativos).dt.days > 90]
            
            response = f"""
üéØ **ESTRAT√âGIAS DE MARKETING AVAN√áADAS**

üìä **Cen√°rio Atual:**
‚Ä¢ Receita Total: R$ {total_vendas:,.2f}
‚Ä¢ Ticket M√©dio: R$ {ticket_medio:.2f}
‚Ä¢ Total de Clientes: {total_clientes:,}
‚Ä¢ Clientes Inativos: {len(clientes_inativos):,}

üöÄ **Estrat√©gia 1: Reativa√ß√£o de Clientes**
‚Ä¢ Investimento Estimado: R$ {len(clientes_inativos) * 50:,.2f}
‚Ä¢ ROI Esperado: 300-500%
‚Ä¢ A√ß√£o: Campanha personalizada para {len(clientes_inativos)} clientes inativos
‚Ä¢ Desconto: 15% no primeiro pedido

üí∞ **Estrat√©gia 2: Upselling Premium**
‚Ä¢ Investimento: R$ {total_clientes * 20:,.2f}
‚Ä¢ ROI Esperado: 200-400%
‚Ä¢ A√ß√£o: Promo√ß√£o de produtos premium
‚Ä¢ Foco: Aumentar ticket m√©dio de R$ {ticket_medio:.2f} para R$ {ticket_medio * 1.3:.2f}

üéÅ **Estrat√©gia 3: Programa de Fidelidade**
‚Ä¢ Investimento: R$ {total_clientes * 30:,.2f}
‚Ä¢ ROI Esperado: 150-300%
‚Ä¢ A√ß√£o: Sistema de pontos e recompensas
‚Ä¢ Benef√≠cio: Reten√ß√£o de clientes

üì± **Estrat√©gia 4: Marketing Digital**
‚Ä¢ Investimento: R$ {total_clientes * 10:,.2f}
‚Ä¢ ROI Esperado: 100-250%
‚Ä¢ A√ß√£o: Campanhas no WhatsApp e redes sociais
‚Ä¢ Foco: Novos clientes e reativa√ß√£o

üìà **Proje√ß√£o de Resultados:**
‚Ä¢ Receita Adicional Esperada: R$ {total_vendas * 0.3:,.2f} (+30%)
‚Ä¢ Novos Clientes: {int(total_clientes * 0.2):,} (+20%)
‚Ä¢ Ticket M√©dio: R$ {ticket_medio * 1.15:.2f} (+15%)
"""
            
            return response
            
        except Exception as e:
            return f"‚ùå Erro na gera√ß√£o de estrat√©gias: {str(e)}"
    
    def generate_executive_report_vercel(self) -> str:
        """Relat√≥rio executivo completo sem ML"""
        try:
            pedidos_df = self.processor.dataframes.get('pedidos')
            if pedidos_df is None or pedidos_df.empty:
                return "‚ùå Dados de pedidos n√£o dispon√≠veis. Processe os dados primeiro."
            
            # M√©tricas principais
            total_vendas = pedidos_df['Total'].sum()
            total_pedidos = len(pedidos_df)
            ticket_medio = pedidos_df['Total'].mean()
            total_clientes = pedidos_df['Cliente'].nunique()
            
            # An√°lise temporal
            pedidos_df['Data Fechamento'] = pd.to_datetime(pedidos_df['Data Fechamento'])
            periodo_inicio = pedidos_df['Data Fechamento'].min()
            periodo_fim = pedidos_df['Data Fechamento'].max()
            
            # An√°lise de origem
            origem_analise = pedidos_df['Origem'].value_counts()
            
            response = f"""
üìã **RELAT√ìRIO EXECUTIVO COMPLETO**

üìä **M√©tricas Principais:**
‚Ä¢ Receita Total: R$ {total_vendas:,.2f}
‚Ä¢ Total de Pedidos: {total_pedidos:,}
‚Ä¢ Ticket M√©dio: R$ {ticket_medio:.2f}
‚Ä¢ Total de Clientes: {total_clientes:,}

üìÖ **Per√≠odo Analisado:**
‚Ä¢ De: {periodo_inicio.strftime('%d/%m/%Y')}
‚Ä¢ At√©: {periodo_fim.strftime('%d/%m/%Y')}
‚Ä¢ Dura√ß√£o: {(periodo_fim - periodo_inicio).days} dias

üõí **An√°lise por Origem:**
{origem_analise.to_string()}

üéØ **Principais Insights:**
‚Ä¢ Origem principal: {origem_analise.index[0]} ({origem_analise.iloc[0]} pedidos)
‚Ä¢ M√©dia di√°ria: R$ {total_vendas / (periodo_fim - periodo_inicio).days:.2f}
‚Ä¢ Pedidos por cliente: {total_pedidos / total_clientes:.1f}

üí° **Recomenda√ß√µes Estrat√©gicas:**
1. Foque em {origem_analise.index[0]} para maximizar vendas
2. Implemente programa de fidelidade
3. Campanha de reativa√ß√£o para clientes inativos
4. Otimiza√ß√£o de hor√°rios de pico
5. Expans√£o de produtos premium

üìà **Proje√ß√µes:**
‚Ä¢ Crescimento esperado: 20-30% com estrat√©gias implementadas
‚Ä¢ ROI estimado: 200-400% em campanhas de marketing
‚Ä¢ Potencial de mercado: R$ {total_vendas * 1.5:,.2f} (+50%)
"""
            
            return response
            
        except Exception as e:
            return f"‚ùå Erro no relat√≥rio executivo: {str(e)}"
    
    def handle_unknown_question_vercel(self, question: str) -> str:
        """Tratamento de perguntas n√£o reconhecidas"""
        return f"""
ü§ñ **IA ZapChicken - Vers√£o Vercel**

N√£o entendi sua pergunta: "{question}"

üí° **Perguntas que posso responder:**

üìä **An√°lise de Vendas:**
‚Ä¢ "Quem comprou em [data]?"
‚Ä¢ "Como est√£o as vendas?"
‚Ä¢ "Qual o total de vendas?"

üë• **An√°lise de Clientes:**
‚Ä¢ "Quantos clientes inativos temos?"
‚Ä¢ "Quais os melhores clientes?"
‚Ä¢ "Como reativar clientes?"

üí∞ **An√°lise Financeira:**
‚Ä¢ "Qual o ticket m√©dio?"
‚Ä¢ "Quais os produtos mais vendidos?"
‚Ä¢ "Como aumentar o faturamento?"

üó∫Ô∏è **An√°lise Geogr√°fica:**
‚Ä¢ "Quais os melhores bairros?"
‚Ä¢ "Onde devo focar marketing?"

üìà **Previs√µes:**
‚Ä¢ "Qual a tend√™ncia de vendas?"
‚Ä¢ "Como ser√° o pr√≥ximo m√™s?"

üéØ **Estrat√©gias:**
‚Ä¢ "Gere estrat√©gias de marketing"
‚Ä¢ "Relat√≥rio executivo completo"

Tente reformular sua pergunta usando essas palavras-chave!
"""
